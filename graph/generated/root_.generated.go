// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"ThaiLy/graph/model"
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Account struct {
		Address  func(childComplexity int) int
		Avatar   func(childComplexity int) int
		Birthday func(childComplexity int) int
		Code     func(childComplexity int) int
		Email    func(childComplexity int) int
		FullName func(childComplexity int) int
		ID       func(childComplexity int) int
		Msg      func(childComplexity int) int
		Phone    func(childComplexity int) int
		Sex      func(childComplexity int) int
		Token    func(childComplexity int) int
	}

	Category struct {
		Deleted     func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Position    func(childComplexity int) int
		Product     func(childComplexity int, productInput *model.ProductInput) int
		Slug        func(childComplexity int) int
		Status      func(childComplexity int) int
		Thumbnail   func(childComplexity int) int
		Title       func(childComplexity int) int
	}

	Mutation struct {
		CreateOtp       func(childComplexity int, email string) int
		LoginAccount    func(childComplexity int, account model.LoginAccountInput) int
		RegisterAccount func(childComplexity int, account model.RegisterAccountInput) int
		UpdateAccount   func(childComplexity int, account *model.UpdateAccountInput) int
	}

	OTP struct {
		Code func(childComplexity int) int
		Msg  func(childComplexity int) int
	}

	Product struct {
		Description     func(childComplexity int) int
		DiscountPercent func(childComplexity int) int
		Featured        func(childComplexity int) int
		ID              func(childComplexity int) int
		Position        func(childComplexity int) int
		Price           func(childComplexity int) int
		Slug            func(childComplexity int) int
		Status          func(childComplexity int) int
		Stock           func(childComplexity int) int
		Thumbnail       func(childComplexity int) int
		Title           func(childComplexity int) int
	}

	Query struct {
		GetAccount  func(childComplexity int) int
		GetCategory func(childComplexity int, categoryID *string) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Account.address":
		if e.complexity.Account.Address == nil {
			break
		}

		return e.complexity.Account.Address(childComplexity), true

	case "Account.avatar":
		if e.complexity.Account.Avatar == nil {
			break
		}

		return e.complexity.Account.Avatar(childComplexity), true

	case "Account.birthday":
		if e.complexity.Account.Birthday == nil {
			break
		}

		return e.complexity.Account.Birthday(childComplexity), true

	case "Account.code":
		if e.complexity.Account.Code == nil {
			break
		}

		return e.complexity.Account.Code(childComplexity), true

	case "Account.email":
		if e.complexity.Account.Email == nil {
			break
		}

		return e.complexity.Account.Email(childComplexity), true

	case "Account.fullName":
		if e.complexity.Account.FullName == nil {
			break
		}

		return e.complexity.Account.FullName(childComplexity), true

	case "Account.id":
		if e.complexity.Account.ID == nil {
			break
		}

		return e.complexity.Account.ID(childComplexity), true

	case "Account.msg":
		if e.complexity.Account.Msg == nil {
			break
		}

		return e.complexity.Account.Msg(childComplexity), true

	case "Account.phone":
		if e.complexity.Account.Phone == nil {
			break
		}

		return e.complexity.Account.Phone(childComplexity), true

	case "Account.sex":
		if e.complexity.Account.Sex == nil {
			break
		}

		return e.complexity.Account.Sex(childComplexity), true

	case "Account.token":
		if e.complexity.Account.Token == nil {
			break
		}

		return e.complexity.Account.Token(childComplexity), true

	case "Category.deleted":
		if e.complexity.Category.Deleted == nil {
			break
		}

		return e.complexity.Category.Deleted(childComplexity), true

	case "Category.description":
		if e.complexity.Category.Description == nil {
			break
		}

		return e.complexity.Category.Description(childComplexity), true

	case "Category.id":
		if e.complexity.Category.ID == nil {
			break
		}

		return e.complexity.Category.ID(childComplexity), true

	case "Category.position":
		if e.complexity.Category.Position == nil {
			break
		}

		return e.complexity.Category.Position(childComplexity), true

	case "Category.product":
		if e.complexity.Category.Product == nil {
			break
		}

		args, err := ec.field_Category_product_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Category.Product(childComplexity, args["ProductInput"].(*model.ProductInput)), true

	case "Category.slug":
		if e.complexity.Category.Slug == nil {
			break
		}

		return e.complexity.Category.Slug(childComplexity), true

	case "Category.status":
		if e.complexity.Category.Status == nil {
			break
		}

		return e.complexity.Category.Status(childComplexity), true

	case "Category.thumbnail":
		if e.complexity.Category.Thumbnail == nil {
			break
		}

		return e.complexity.Category.Thumbnail(childComplexity), true

	case "Category.title":
		if e.complexity.Category.Title == nil {
			break
		}

		return e.complexity.Category.Title(childComplexity), true

	case "Mutation.createOtp":
		if e.complexity.Mutation.CreateOtp == nil {
			break
		}

		args, err := ec.field_Mutation_createOtp_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateOtp(childComplexity, args["email"].(string)), true

	case "Mutation.loginAccount":
		if e.complexity.Mutation.LoginAccount == nil {
			break
		}

		args, err := ec.field_Mutation_loginAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.LoginAccount(childComplexity, args["account"].(model.LoginAccountInput)), true

	case "Mutation.registerAccount":
		if e.complexity.Mutation.RegisterAccount == nil {
			break
		}

		args, err := ec.field_Mutation_registerAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegisterAccount(childComplexity, args["account"].(model.RegisterAccountInput)), true

	case "Mutation.updateAccount":
		if e.complexity.Mutation.UpdateAccount == nil {
			break
		}

		args, err := ec.field_Mutation_updateAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateAccount(childComplexity, args["account"].(*model.UpdateAccountInput)), true

	case "OTP.code":
		if e.complexity.OTP.Code == nil {
			break
		}

		return e.complexity.OTP.Code(childComplexity), true

	case "OTP.msg":
		if e.complexity.OTP.Msg == nil {
			break
		}

		return e.complexity.OTP.Msg(childComplexity), true

	case "Product.description":
		if e.complexity.Product.Description == nil {
			break
		}

		return e.complexity.Product.Description(childComplexity), true

	case "Product.discountPercent":
		if e.complexity.Product.DiscountPercent == nil {
			break
		}

		return e.complexity.Product.DiscountPercent(childComplexity), true

	case "Product.featured":
		if e.complexity.Product.Featured == nil {
			break
		}

		return e.complexity.Product.Featured(childComplexity), true

	case "Product.id":
		if e.complexity.Product.ID == nil {
			break
		}

		return e.complexity.Product.ID(childComplexity), true

	case "Product.position":
		if e.complexity.Product.Position == nil {
			break
		}

		return e.complexity.Product.Position(childComplexity), true

	case "Product.price":
		if e.complexity.Product.Price == nil {
			break
		}

		return e.complexity.Product.Price(childComplexity), true

	case "Product.slug":
		if e.complexity.Product.Slug == nil {
			break
		}

		return e.complexity.Product.Slug(childComplexity), true

	case "Product.status":
		if e.complexity.Product.Status == nil {
			break
		}

		return e.complexity.Product.Status(childComplexity), true

	case "Product.stock":
		if e.complexity.Product.Stock == nil {
			break
		}

		return e.complexity.Product.Stock(childComplexity), true

	case "Product.thumbnail":
		if e.complexity.Product.Thumbnail == nil {
			break
		}

		return e.complexity.Product.Thumbnail(childComplexity), true

	case "Product.title":
		if e.complexity.Product.Title == nil {
			break
		}

		return e.complexity.Product.Title(childComplexity), true

	case "Query.getAccount":
		if e.complexity.Query.GetAccount == nil {
			break
		}

		return e.complexity.Query.GetAccount(childComplexity), true

	case "Query.getCategory":
		if e.complexity.Query.GetCategory == nil {
			break
		}

		args, err := ec.field_Query_getCategory_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetCategory(childComplexity, args["categoryID"].(*string)), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateOtpInput,
		ec.unmarshalInputLoginAccountInput,
		ec.unmarshalInputProductInput,
		ec.unmarshalInputRegisterAccountInput,
		ec.unmarshalInputUpdateAccountInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/account.graphqls", Input: `
# Định nghĩa loại Account
type Account {
  id: Int
  fullName: String
  email: String
  address: String # Đã sửa lỗi chính tả
  phone: String
  avatar: String
  sex: String
  birthday: String
  token: String
  code: String
  msg: String
}


# Định nghĩa Input để đăng ký tài khoản
input RegisterAccountInput {
  fullName: String!
  email: String!
  password: String!
  otp: String!
}

# Định nghĩa Input để đăng nhập tài khoản
input LoginAccountInput {
  email: String!
  password: String!
}

# Định nghĩa Input để cập nhật tài khoản
input UpdateAccountInput {
  fullName: String
  adress: String
  phone: String
  avatar: String
  sex: String
  birthday: String
}

# Định nghĩa loại OTP
type OTP {
  code: String
  msg: String
}

# Định nghĩa Input để tạo OTP
input CreateOtpInput {
  email: String!
}
`, BuiltIn: false},
	{Name: "../schema/category.graphqls", Input: `
# Định nghĩa loại Category
type Category {
  id: Int
  title: String
  description: String
  thumbnail: String
  status: String
  position: String
  deleted: Boolean
  slug: String
  product(ProductInput: ProductInput): [Product]
}
`, BuiltIn: false},
	{Name: "../schema/mutation.graphqls", Input: `
# Định nghĩa Mutaion type
type Mutation {
  loginAccount(account: LoginAccountInput!): Account
  registerAccount(account: RegisterAccountInput!): Account
  updateAccount(account: UpdateAccountInput): Account
  createOtp(email: String!): OTP
}
`, BuiltIn: false},
	{Name: "../schema/product.graphqls", Input: `# Định nghĩa loại Product
type Product {
  id: Int
  title: String
  description: String
  thumbnail: String # Đã sửa lỗi chính tả
  price: String
  discountPercent: String
  stock: String
  status: String
  position: String
  slug: String
  featured: String
}

# Định nghĩa Input cho Product
input ProductInput {
  offset: Int
  limit: Int
  featured: String
}`, BuiltIn: false},
	{Name: "../schema/query.graphqls", Input: `# Định nghĩa Query type
type Query {
  getAccount: Account
  getCategory(categoryID: String): [Category]
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
